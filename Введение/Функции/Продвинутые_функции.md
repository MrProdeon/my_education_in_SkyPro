# Позиционные аргументы

### Позиционные аргументы — это аргументы, передаваемые в функцию в порядке их определения в функции. То есть порядок аргументов в вызове функции должен соответствовать порядку, в котором они определены в объявлении функции.

```python
def greet(name, greeting):
    return f"{greeting}, {name}!"


result = greet("Alice", "Hello")
print(result)

>>> Hello, Alice!

name встает Alice, greeting встает Hello
```

```python
def greet(name, greeting):
    return f"{greeting}, {name}!"


result = greet("Hello", "Alice")
print(result)

>>> Alice, Hello!

name встает Hello, greeting встает Alice
```

# Именованные аргументы

### Именованные аргументы — это аргументы, передаваемые в функцию с явным указанием их имени. Это позволяет изменять порядок передаваемых значений, если явно указать, какому параметру они принадлежат.

```python
def greet(name, greeting):
    return f"{greeting}, {name}!"


result = greet(greeting="Hi", name="Bob")
print(result)

>>> Hi, Bob!
```

### При вызове функции greet(greeting="Hi", name="Bob") значение "Hi" передается параметру greeting, а "Bob" — параметру name.

В случае если мы поменяем местами аргументы при вызове, но оставим их именованными, результат работы функции не изменится, так как явно указываются имена параметров, в которые передаются конкретные значения.

# Параметры функций со значениями по умолчанию

### Мы можем определить значения по умолчанию для параметров функции. Это означает, что, если значение для параметра не передано при вызове функции, будет использовано то значение, которое указано как значение по умолчанию. Такие параметры функции еще могут называть опциональными.

```python
def func(param_1, param_2=default_value):
    some_code
```

**func** — имя функции;
 
**param_1** — параметр функции, для которого не задано значение по умолчанию;
 
***param_2** — параметр функции, для которого указано значение по умолчанию;
 
**=** — знак равенства указывает на то, что далее будет следовать значение по умолчанию для параметра;
 
**default_value** — непосредственно значение по умолчанию.

```python 
def greet(name, greeting="Hello", punctuation="."):
    return f"{greeting}, {name}{punctuation}"


result = greet("Charlie", punctuation="!")
print(result)

>>> Hello, Charlie!
```

При вызове функции мы передаем значение для параметра 
name. Оно должно быть обязательно передано, так как не имеет значения по умолчанию, а вот два остальных параметра — 
punctuation и 
greeting — имеют значения по умолчанию. Мы передали новое значение только для 
punctuation, а параметр 
greeting использует свое значение по умолчанию.

# В пайтон есть особенность при передачи изменяемого объекта в виде параметра по умолчанию

### В Python нужно осторожно использовать изменяемые типы данных, такие как списки или словари, в качестве значений по умолчанию для параметров функций. Это связано с особенностью того, как происходит вычисление значений по умолчанию при определении функции.

### При определении функции значения по умолчанию вычисляются только один раз, в момент создания функции. Затем эти значения кешируются (сохраняются в памяти, а не пересоздаются) и используются в каждом вызове функции, если не было передано нового значения для параметра. Если значение по умолчанию — изменяемый объект и этот объект изменяется внутри функции, то изменения будут видны в последующих вызовах функции.

```python
def add_item(value, my_list=[]):
    my_list.append(value)
    return my_list


result_1 = add_item(1)
print(result_1)

>>> [1]

result_2 = add_item(2)
print(result_2)  # Ожидаем [2]

>>> [1, 2] # А ожидалось [2]
```

В этом примере список my_list
 используется в качестве значения по умолчанию. Когда мы вызываем функцию add_item(1), 1 добавляется в список. Затем, когда мы вызываем функцию add_item(2)
 без передачи нового значения для my_list, значение по умолчанию (кешированное при создании функции) уже содержит 1, и 2 добавляется к этому списку. Таким образом, результат второго вызова функции не ожидаемо включает 1.

Чтобы избежать подобных проблем, вместо изменяемых объектов лучше использовать неизменяемые объекты в качестве значений по умолчанию, например 
None, и затем внутри функции проверять, был ли передан аргумент, и при необходимости создавать новый объект:

```python
def add_item(value, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(value)
    return my_list

result_1 = add_item(1)
print(result_1)

>>> [1]

result_2 = add_item(2)
print(result_2)

>>> [2]
```

# Параметры неопределенного размера

# *args — позиционные аргументы

### Аргумент *args в Python представляет собой механизм для обработки произвольного количества позиционных аргументов в функции. Звездочка * перед именем аргумента args указывает на то, что все переданные позиционные аргументы после этой звездочки будут собраны в кортеж.

```python
def print_args(*args):
    for arg in args:
        print(arg)


print_args(1, 'two', 3.0)

>>> 1
    two
    3.0
```

# **kwargs — именованные аргументы

### Параметр **kwargs представляет собой механизм для обработки произвольного количества именованных (ключ — значение) аргументов в функции. Две звездочки ** перед именем kwargs указывают, что все переданные именованные аргументы после этой звездочки будут собраны в словарь.

```python
def print_kwargs(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")


print_kwargs(name='John', age=25, city='New York')

>>> name: John
    age: 25
    city: New York
```

# Использование *args и **kwargs вместе

Можно использовать *args  и **kwargs вместе в функции, чтобы принимать произвольное количество позиционных и именованных аргументов одновременно.
```python
def print_args_and_kwargs(*args, **kwargs):
    for arg in args:
        print(arg)
    for key, value in kwargs.items():
        print(f"{key}: {value}")


print_args_and_kwargs(1, 'two', 3.0, name='John', age=25)

>>> 1
    two
    3.0
    name: John
    age: 25
```

# Распаковка аргументов функции

### Распаковка аргументов — это механизм, который позволяет передавать элементы последовательности (списка, строки или другой коллекции) или элементы словаря как отдельные аргументы функции.

Синтаксис распаковки аргументов включает использование операторов * (звездочка) и **(две звездочки) в вызове функции:

```
my_function(*my_list)

my_function(**my_dict)
```

### Распаковка для позиционных аргументов *args


```python
def example_function(a, b, c):
    print(f"a: {a}, b: {b}, c: {c}")


# Создаем список
my_list = [1, 2, 3]

# Распаковываем список и передаем его значения в функцию
example_function(*my_list)

>>> a: 1, b: 2, c: 3
```

Здесь *my_list распаковывает элементы списка my_list и передает их в функцию example_function в порядке их следования в списке. То есть в параметр a записывается первое значение списка my_list — 1, в значение b — 2, в значение c — 3.

### Распаковка для именованных аргументов **kwargs


```python
def example_function(name, age, city):
    print(f"name: {name}, age: {age}, city: {city}")


# Создаем словарь
my_dict = {'name': 'Alice', 'age': 30, 'city': 'Wonderland'}

# Распаковываем словарь и передаем его значения в функцию
example_function(**my_dict)

>>> name: Alice, age: 30, city: Wonderland
```

Здесь **my_dict распаковывает ключи и значения словаря my_dict и передает их в функцию example_function. Ключи словаря соответствуют именам параметров функции.


# Распаковка *args и **kwargs одновременно


```python
def example_function(a, b, c, d):
    print(f"a: {a}, b: {b}, c: {c}, d: {d}")


# Создаем список и словарь
my_list = [1, 2]
my_dict = {'c': 3, 'd': 4}

# Распаковываем список и словарь, передаем их значения в функцию
example_function(*my_list, **my_dict)

>>> a: 1, b: 2, c: 3, d: 4
```

В этом случае мы используем *my_list для распаковки позиционных аргументов из my_list, а 
**my_dict — для именованных аргументов из my_dict. Это также называется комбинированной распаковкой.

# Возможные ошибки при указании аргументов

### Количество позиционных аргументов в вызове функции должно соответствовать количеству параметров, объявленных в функции. Если передано недостаточное или избыточное количество аргументов, это может привести к ошибкам или неожиданным результатам.

Недостаточное количество позиционных аргументов

Избыточное количество позиционных аргументов



### При передаче именованных аргументов в функцию важно, чтобы количество именованных аргументов и их названия соответствовали ожиданиям функции. В противном случае могут возникнуть ошибки.

Недостаточное количество именованных аргументов

Избыточное количество именованных аргументов







